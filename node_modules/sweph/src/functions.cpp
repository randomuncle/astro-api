#include <sweph.h>

constexpr std::pair<int, const char*> args0[] = {
	{ 6, "Expecting 6 arguments: tjd_ut, calc_flag, geopos, atpress, attemp, xin" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - calculation flag, 0 for SE_ECL2HOR, 1 for SE_EQU2HOR" },
	{ ARRAY, "Argument 3 should be an array of 3 numbers - geographic coordinates [longitude, latitude, elevation]" },
	{ NUMBER, "Argument 4 should be a number - atmospheric pressure in mbar/hpa" },
	{ NUMBER, "Argument 5 should be a number - atmospheric temperature in celsius" },
	{ ARRAY, "Argument 6 should be an array of 3 numbers - ecliptic or equatorial coordinates depending on argument 2 [lon/ra, lat/dec, distance]" }
};

Napi::Value sweph_azalt(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args0, info)) {
		return env.Null();
	}
	double geopos [3];
	if(!sweph_double_array_converter(geopos, 3, info[2])) {
		Napi::TypeError::New(env, args0[3].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double xin [3];
	if(!sweph_double_array_converter(xin, 3, info[5])) {
		Napi::TypeError::New(env, args0[6].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double out [3];
	swe_azalt(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		geopos,
		info[3].As<Napi::Number>().DoubleValue(),
		info[4].As<Napi::Number>().DoubleValue(),
		xin,
		out
	);
	return sweph_js_array_converter(out, 3, env);
}


constexpr std::pair<int, const char*> args1[] = {
	{ 4, "Expecting 4 arguments: tjd_ut, calc_flag, geopos, xin" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - calculation flag, 0 for SE_HOR2ECL, 1 for SE_HOR2EQU" },
	{ ARRAY, "Argument 3 should be an array of 3 numbers - geographic coordinates [longitude, latitude, elevation]" },
	{ ARRAY, "Argument 4 should be an array of 2 numbers - horizontal coordinates [azimuth, true altitude]" }
};

Napi::Value sweph_azalt_rev(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args1, info)) {
		return env.Null();
	}
	double geopos [3];
	if(!sweph_double_array_converter(geopos, 3, info[2])) {
		Napi::TypeError::New(env, args1[3].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double xin [2];
	if(!sweph_double_array_converter(xin, 2, info[3])) {
		Napi::TypeError::New(env, args1[4].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double out [2];
	swe_azalt_rev(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		geopos,
		xin,
		out
	);
	return sweph_js_array_converter(out, 2, env);
}


constexpr std::pair<int, const char*> args2[] = {
	{ 3, "Expecting 3 arguments: tjd, ipl, iflag" },
	{ NUMBER, "Argument 1 should be a number - julian day in ephemeris/terrestrial time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_calc(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args2, info)) {
		return env.Null();
	}
	double xx [6];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_calc(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		xx,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(xx, 6, env);
	return obj;
}


constexpr std::pair<int, const char*> args3[] = {
	{ 4, "Expecting 4 arguments: tjd, ipl, iplctr, iflag" },
	{ NUMBER, "Argument 1 should be a number - julian day in terrestrial/ephemeris time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ NUMBER, "Argument 3 should be a number - center object ID" },
	{ NUMBER, "Argument 4 should be a number - calculation flag" }
};

Napi::Value sweph_calc_pctr(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args3, info)) {
		return env.Null();
	}
	double xx [6];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_calc_pctr(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		info[3].As<Napi::Number>().Int32Value(),
		xx,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(xx, 6, env);
	return obj;
}


constexpr std::pair<int, const char*> args4[] = {
	{ 3, "Expecting 3 arguments: tjd, ipl, iflag" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_calc_ut(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args4, info)) {
		return env.Null();
	}
	double xx [6];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_calc_ut(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		xx,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(xx, 6, env);
	return obj;
}


void sweph_close(const Napi::CallbackInfo& info) {
	swe_close();
	return;
}


constexpr std::pair<int, const char*> args6[] = {
	{ 2, "Expecting 2 arguments: xpo, eps" },
	{ ARRAY, "Argument 1 should be an array of 3 numbers - source coordinates [lon, lat, dist]" },
	{ NUMBER, "Argument 2 should be a number - obliquity of the ecliptic in decimal degrees" }
};

Napi::Value sweph_cotrans(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args6, info)) {
		return env.Null();
	}
	double in [3];
	if(!sweph_double_array_converter(in, 3, info[0])) {
		Napi::TypeError::New(env, args6[1].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double out [3];
	swe_cotrans(
		in,
		out,
		info[1].As<Napi::Number>().DoubleValue()
	);
	return sweph_js_array_converter(out, 3, env);
}


constexpr std::pair<int, const char*> args7[] = {
	{ 2, "Expecting 2 arguments: xpo, eps" },
	{ ARRAY, "Argument 1 should be an array of 6 numbers - source coordinates [lon, lat, dist, lonspd, latspd, distspd]" },
	{ NUMBER, "Argument 2 should be a number - obliquity of the ecliptic in decimal degrees" }
};

Napi::Value sweph_cotrans_sp(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args7, info)) {
		return env.Null();
	}
	double in [6];
	if(!sweph_double_array_converter(in, 6, info[0])) {
		Napi::TypeError::New(env, args7[1].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double out [6];
	swe_cotrans_sp(
		in,
		out,
		info[1].As<Napi::Number>().DoubleValue()
	);
	return sweph_js_array_converter(out, 6, env);
}


constexpr std::pair<int, const char*> args8[] = {
	{ 1, "Expecting 1 argument: csec" },
	{ NUMBER, "Argument 1 should be a number - degrees in centiseconds" }
};

Napi::Value sweph_cs2degstr(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args8, info)) {
		return env.Null();
	}
	char out [AS_MAXCH];
	swe_cs2degstr(
		info[0].As<Napi::Number>().Int32Value(),
		out
	);
	return Napi::String::New(env, out);
}


constexpr std::pair<int, const char*> args9[] = {
	{ 3, "Expecting 3 arguments: csec, pchar, mchar" },
	{ NUMBER, "Argument 1 should be a number - degrees in centiseconds" },
	{ STRING, "Argument 2 should be a string - sign character for positive values" },
	{ STRING, "Argument 3 should be a string - sign character for negative values" }
};

Napi::Value sweph_cs2lonlatstr(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args9, info)) {
		return env.Null();
	}
	char out [AS_MAXCH];
	swe_cs2lonlatstr(
		info[0].As<Napi::Number>().Int32Value(),
		info[1].As<Napi::String>().Utf8Value()[0],
		info[2].As<Napi::String>().Utf8Value()[0],
		out
	);
	return Napi::String::New(env, out);
}


constexpr std::pair<int, const char*> args10[] = {
	{ 3, "Expecting 3 arguments: csec, sep, supzero" },
	{ NUMBER, "Argument 1 should be a number - degrees in centiseconds" },
	{ STRING, "Argument 2 should be a string - separator character" },
	{ TRUEFALSE, "Argument 3 should be a boolean - omit seconds if they are zero" }
};

Napi::Value sweph_cs2timestr(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args10, info)) {
		return env.Null();
	}
	char out [AS_MAXCH];
	swe_cs2timestr(
		info[0].As<Napi::Number>().Int32Value(),
		int(info[1].As<Napi::String>().Utf8Value()[0]),
		info[2].As<Napi::Boolean>(),
		out
	);
	return Napi::String::New(env, out);
}


constexpr std::pair<int, const char*> args11[] = {
	{ 1, "Expecting 1 argument: csec" },
	{ NUMBER, "Argument 1 should be a number - degrees in centiseconds" }
};

Napi::Value sweph_csnorm(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args11, info)) {
		return env.Null();
	}
	int32 val = swe_csnorm(info[0].As<Napi::Number>().Int32Value());
	return Napi::Number::New(env, val);
}


constexpr std::pair<int, const char*> args12[] = {
	{ 1, "Expecting 1 argument: csec" },
	{ NUMBER, "Argument 1 should be a number - degrees in centiseconds" }
};

Napi::Value sweph_csroundsec(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args12, info)) {
		return env.Null();
	}
	int32 val = swe_csroundsec(info[0].As<Napi::Number>().Int32Value());
	return Napi::Number::New(env, val);
}


constexpr std::pair<int, const char*> args13[] = {
	{ 1, "Expecting 1 argument: double" },
	{ NUMBER, "Argument 1 should be a number - double value" }
};

Napi::Value sweph_d2l(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args13, info)) {
		return env.Null();
	}
	int32 val = swe_d2l(info[0].As<Napi::Number>().DoubleValue());
	return Napi::Number::New(env, val);
}


constexpr std::pair<int, const char*> args14[] = {
	{ 5, "Expecting 5 arguments: year, month, day, hour, calendar" },
	{ NUMBER, "Argument 1 should be a number - full year" },
	{ NUMBER, "Argument 2 should be a number - month 1-12" },
	{ NUMBER, "Argument 3 should be a number - day 1-31" },
	{ NUMBER, "Argument 4 should be a number - hour with decimal fraction 0-23.999" },
	{ STRING, "Argument 5 should be a string - calendar system, 'g' for gregorian calendar, 'j' for julian calendar" }
};

Napi::Value sweph_date_conversion(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args14, info)) {
		return env.Null();
	}
	double ret;
	int flag = swe_date_conversion(
		info[0].As<Napi::Number>().Int32Value(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		info[3].As<Napi::Number>().DoubleValue(),
		info[4].As<Napi::String>().Utf8Value()[0],
		&ret
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["data"] = ret;
	return obj;
}


constexpr std::pair<int, const char*> args15[] = {
	{ 1, "Expecting 1 argument: jd" },
	{ NUMBER, "Argument 1 should be a number - julian day" }
};

Napi::Value sweph_day_of_week(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args15, info)) {
		return env.Null();
	}
	int val = swe_day_of_week(info[0].As<Napi::Number>().DoubleValue());
	return Napi::Number::New(env, val);
}


constexpr std::pair<int, const char*> args16[] = {
	{ 1, "Expecting 1 argument: deg" },
	{ NUMBER, "Argument 1 should be a number: decimal degrees" }
};

Napi::Value sweph_degnorm(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args16, info)) {
		return env.Null();
	}
	double val = swe_degnorm(info[0].As<Napi::Number>().DoubleValue());
	return Napi::Number::New(env, val);
}


constexpr std::pair<int, const char*> args17[] = {
	{ 1, "Expecting 1 argument: tjd" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" }
};

Napi::Value sweph_deltat(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args17, info)) {
		return env.Null();
	}
	double delta = swe_deltat(info[0].As<Napi::Number>().DoubleValue());
	return Napi::Number::New(env, delta);
}


constexpr std::pair<int, const char*> args18[] = {
	{ 2, "Expecting 2 arguments: tjd, ephe" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - ephemeris flag" }
};

Napi::Value sweph_deltat_ex(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args18, info)) {
		return env.Null();
	}
	char serr [AS_MAXCH] = "";
	double delta = swe_deltat_ex(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["error"] = serr;
	obj["data"] = delta;
	return obj;
}


constexpr std::pair<int, const char*> args19[] = {
	{ 2, "Expecting 2 arguments: csec, csec" },
	{ NUMBER, "Argument 1 should be a number - degrees in centiseconds" },
	{ NUMBER, "Argument 2 should be a number - degrees in centiseconds" }
};

Napi::Value sweph_difcs2n(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args19, info)) {
		return env.Null();
	}
	int32 dif = swe_difcs2n(
		info[0].As<Napi::Number>().Int32Value(),
		info[1].As<Napi::Number>().Int32Value()
	);
	return Napi::Number::New(env, dif);
}


constexpr std::pair<int, const char*> args20[] = {
	{ 2, "Expecting 2 arguments: csec, csec" },
	{ NUMBER, "Argument 1 should be a number - degrees in centiseconds" },
	{ NUMBER, "Argument 2 should be a number - degrees in centiseconds" }
};

Napi::Value sweph_difcsn(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args20, info)) {
		return env.Null();
	}
	int32 dif = swe_difcsn(
		info[0].As<Napi::Number>().Int32Value(),
		info[1].As<Napi::Number>().Int32Value()
	);
	return Napi::Number::New(env, dif);
}


constexpr std::pair<int, const char*> args21[] = {
	{ 2, "Expecting 2 arguments: deg, deg" },
	{ NUMBER, "Argument 1 should be a number - decimal degrees" },
	{ NUMBER, "Argument 2 should be a number - decimal degrees" }
};

Napi::Value sweph_difdeg2n(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args21, info)) {
		return env.Null();
	}
	double dif = swe_difdeg2n(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue()
	);
	return Napi::Number::New(env, dif);
}


constexpr std::pair<int, const char*> args22[] = {
	{ 2, "Expecting 2 arguments: deg, deg" },
	{ NUMBER, "Argument 1 should be a number - decimal degrees" },
	{ NUMBER, "Argument 2 should be a number - decimal degrees" }
};

Napi::Value sweph_difdegn(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args22, info)) {
		return env.Null();
	}
	double dif = swe_difdegn(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue()
	);
	return Napi::Number::New(env, dif);
}


constexpr std::pair<int, const char*> args23[] = {
	{ 3, "Expecting 3 arguments: star, tjd_et, iflag" },
	{ STRING, "Argument 1 should be a string - star ID" },
	{ NUMBER, "Argument 2 should be a number - julian day in ephemeris/terrestrial time" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_fixstar(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args23, info)) {
		return env.Null();
	}
	double xx [6];
	char serr [AS_MAXCH] = "";
	char star [AS_MAXCH];
	strcpy(star, info[0].As<Napi::String>().Utf8Value().c_str());
	int32 flag = swe_fixstar(
		star,
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		xx,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["name"] = star;
	obj["data"] = sweph_js_array_converter(xx, 6, env);
	return obj;
}


constexpr std::pair<int, const char*> args24[] = {
	{ 3, "Expecting 3 arguments: star, tjd_et, iflag" },
	{ STRING, "Argument 1 should be a string - star ID" },
	{ NUMBER, "Argument 2 should be a number - julian day in ephemeris/terrestrial time" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_fixstar2(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args24, info)) {
		return env.Null();
	}
	double xx [6];
	char serr [AS_MAXCH] = "";
	char star [AS_MAXCH];
	strcpy(star, info[0].As<Napi::String>().Utf8Value().c_str());
	int32 flag = swe_fixstar2(
		star,
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		xx,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["name"] = star;
	obj["data"] = sweph_js_array_converter(xx, 6, env);
	return obj;
}


constexpr std::pair<int, const char*> args25[] = {
	{ 1, "Expecting 1 argument: star" },
	{ STRING, "Argument 1 should be a string - star ID" }
};

Napi::Value sweph_fixstar2_mag(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args25, info)) {
		return env.Null();
	}
	double mag;
	char serr [AS_MAXCH] = "";
	char star [AS_MAXCH];
	strcpy(star, info[0].As<Napi::String>().Utf8Value().c_str());
	int32 flag = swe_fixstar2_mag(
		star,
		&mag,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["name"] = star;
	obj["data"] = mag;
	return obj;
}


constexpr std::pair<int, const char*> args26[] = {
	{ 3, "Expecting 3 arguments: star, tjd_ut, iflag" },
	{ STRING, "Argument 1 should be a string - star ID" },
	{ NUMBER, "Argument 2 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_fixstar2_ut(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args26, info)) {
		return env.Null();
	}
	double xx [6];
	char serr [AS_MAXCH] = "";
	char star [AS_MAXCH];
	strcpy(star, info[0].As<Napi::String>().Utf8Value().c_str());
	int32 flag = swe_fixstar2_ut(
		star,
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		xx,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["name"] = star;
	obj["data"] = sweph_js_array_converter(xx, 6, env);
	return obj;
}


constexpr std::pair<int, const char*> args27[] = {
	{ 1, "Expecting 1 argument: star" },
	{ STRING, "Argument 1 should be a string - star ID" }
};

Napi::Value sweph_fixstar_mag(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args27, info)) {
		return env.Null();
	}
	double mag;
	char serr [AS_MAXCH] = "";
	char star [AS_MAXCH];
	strcpy(star, info[0].As<Napi::String>().Utf8Value().c_str());
	int32 flag = swe_fixstar_mag(
		star,
		&mag,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["name"] = star;
	obj["data"] = mag;
	return obj;
}


constexpr std::pair<int, const char*> args28[] = {
	{ 3, "Expecting 3 arguments: star, tjd_ut, iflag" },
	{ STRING, "Argument 1 should be a string - star ID" },
	{ NUMBER, "Argument 2 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_fixstar_ut(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args28, info)) {
		return env.Null();
	}
	double xx [6];
	char serr [AS_MAXCH] = "";
	char star [AS_MAXCH];
	strcpy(star, info[0].As<Napi::String>().Utf8Value().c_str());
	int32 flag = swe_fixstar_ut(
		star,
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		xx,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["name"] = star;
	obj["data"] = sweph_js_array_converter(xx, 6, env);
	return obj;
}


constexpr std::pair<int, const char*> args29[] = {
	{ 8, "Expecting 8 arguments: tjd_ut, ipl, starname, iflag, imeth, geopos, atpress, attemp" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - planet ID" },
	{ STRINGNULL, "Argument 3 should be a string or null - star ID if any" },
	{ NUMBER, "Argument 4 should be a number - calculation flag" },
	{ NUMBER, "Argument 5 should be a number - calculation method" },
	{ ARRAY, "Argument 6 should be an array of 3 numbers - geographic coordinates [longitude, latitude, elevation]" },
	{ NUMBER, "Argument 7 should be a number - atmospheric pressure in mbar/hpa" },
	{ NUMBER, "Argument 8 should be a number - atmospheric temperature in celsius" }
};

Napi::Value sweph_gauquelin_sector(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args29, info)) {
		return env.Null();
	}
	double geopos [3];
	if(!sweph_double_array_converter(geopos, 3, info[5])) {
		Napi::TypeError::New(env, args29[6].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double sect;
	char serr [AS_MAXCH] = "";
	int32 flag = swe_gauquelin_sector(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].IsString() ? (char*)info[2].As<Napi::String>().Utf8Value().c_str() : NULL,
		info[3].As<Napi::Number>().Int32Value(),
		info[4].As<Napi::Number>().Int32Value(),
		geopos,
		info[6].As<Napi::Number>().DoubleValue(),
		info[7].As<Napi::Number>().DoubleValue(),
		&sect,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sect;
	return obj;
}


constexpr std::pair<int, const char*> args30[] = {
	{ 1, "Expecting 1 argument: tjd_et" },
	{ NUMBER, "Argument 1 should be a number - julian day in ephemeris/terrestrial time" }
};

Napi::Value sweph_get_ayanamsa(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args30, info)) {
		return env.Null();
	}
	double val = swe_get_ayanamsa(info[0].As<Napi::Number>().DoubleValue());
	return Napi::Number::New(env, val);
}


constexpr std::pair<int, const char*> args31[] = {
	{ 2, "Expecting 2 argument: tjd_et, ephe_flag" },
	{ NUMBER, "Argument 1 should be a number - julian day in ephemeris/terrestrial time" },
	{ NUMBER, "Argument 2 should be a number - ephemeris flag" }
};

Napi::Value sweph_get_ayanamsa_ex(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args31, info)) {
		return env.Null();
	}
	double aya;
	char serr [AS_MAXCH] = "";
	int32 flag = swe_get_ayanamsa_ex(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		&aya,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = aya;
	return obj;
}


constexpr std::pair<int, const char*> args32[] = {
	{ 2, "Expecting 2 argument: tjd_ut, ephe_flag" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - ephemeris flag" }
};

Napi::Value sweph_get_ayanamsa_ex_ut(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args32, info)) {
		return env.Null();
	}
	double aya;
	char serr [AS_MAXCH] = "";
	int32 flag = swe_get_ayanamsa_ex_ut(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		&aya,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = aya;
	return obj;
}


constexpr std::pair<int, const char*> args33[] = {
	{ 1, "Expecting 1 argument: aya" },
	{ NUMBER, "Argument 1 should be a number - ayanamsa ID" }
};

Napi::Value sweph_get_ayanamsa_name(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args33, info)) {
		return env.Null();
	}
	const char* name = swe_get_ayanamsa_name(info[0].As<Napi::Number>().Int32Value());
	if(name == NULL) {
		Napi::TypeError::New(env, "Invalid ayanamsa").ThrowAsJavaScriptException();
		return env.Null();
	}
	return Napi::String::New(env, name);
}


constexpr std::pair<int, const char*> args34[] = {
	{ 1, "Expecting 1 argument: tjd_ut" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" }
};

Napi::Value sweph_get_ayanamsa_ut(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args34, info)) {
		return env.Null();
	}
	double val = swe_get_ayanamsa_ut(info[0].As<Napi::Number>().DoubleValue());
	return Napi::Number::New(env, val);
}


constexpr std::pair<int, const char*> args35[] = {
	{ 1, "Expecting 1 argument: ifno" },
	{ NUMBER, "Argument 1 should be a number - file type" }
};

Napi::Value sweph_get_current_file_data(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args35, info)) {
		return env.Null();
	}
	double tfstart;
	double tfend;
	int denum;
	const char *path = swe_get_current_file_data(
		info[0].As<Napi::Number>().Int32Value(),
		&tfstart,
		&tfend,
		&denum
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["path"] = path;
	obj["start"] = tfstart;
	obj["end"] = tfend;
	obj["denum"] = denum;
	return obj;
}


Napi::String sweph_get_library_path(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	char path [AS_MAXCH];
	swe_get_library_path(path);
	return Napi::String::New(env, path);
}


constexpr std::pair<int, const char*> args37[] = {
	{ 3, "Expecting 3 arguments: tjd_et, ipl, iflag" },
	{ NUMBER, "Argument 1 should be a number - julian day ephemeris/terrestrial time" },
	{ NUMBER, "Argument 2 should be a number - object ID" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_get_orbital_elements(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args37, info)) {
		return env.Null();
	}
	double ret [50];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_get_orbital_elements(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		ret,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(ret, 17, env);
	return obj;
}


constexpr std::pair<int, const char*> args38[] = {
	{ 1, "Expecting 1 argument: ipl" },
	{ NUMBER, "Argument 1 should be a number - object ID" }
};

Napi::Value sweph_get_planet_name(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args38, info)) {
		return env.Null();
	}
	char planet [AS_MAXCH];
	swe_get_planet_name(
		info[0].As<Napi::Number>().Int32Value(),
		planet
	);
	return Napi::String::New(env, planet);
}


Napi::Number sweph_get_tid_acc(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	double val = swe_get_tid_acc();
	return Napi::Number::New(env, val);
}


constexpr std::pair<int, const char*> args40[] = {
	{ 7, "Expecting 7 arguments: tjd_ut, dgeo, datm, dobs, object_name, event_type, hel_flag" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ ARRAY, "Argument 2 should be an array of 3 numbers - geographic coordinates [longitude, latitude, elevation]" },
	{ ARRAY, "Argument 3 should be an array of 4 numbers - atmospheric conditions [pressure, temperature, humidity, meteorological range]" },
	{ ARRAY, "Argument 4 should be an array of 6 numbers - observer description [age, sellen ratio, optical type, optical magnification, optical aperture, optical transmission]" },
	{ STRING, "Argument 5 should be a string - name of fixed star or planet" },
	{ NUMBER, "Argument 6 should be a number - event type" },
	{ NUMBER, "Argument 7 should be a number - calculation flag" }
};

Napi::Value sweph_heliacal_pheno_ut(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args40, info)) {
		return env.Null();
	}
	double dgeo [3];
	if(!sweph_double_array_converter(dgeo, 3, info[1])) {
		Napi::TypeError::New(env, args40[2].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double datm [4];
	if(!sweph_double_array_converter(datm, 4, info[2])) {
		Napi::TypeError::New(env, args40[3].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double dobs [6];
	if(!sweph_double_array_converter(dobs, 6, info[3])) {
		Napi::TypeError::New(env, args40[4].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	char serr [AS_MAXCH] = "";
	double ret [50];
	int32 flag = swe_heliacal_pheno_ut(
		info[0].As<Napi::Number>().DoubleValue(),
		dgeo,
		datm,
		dobs,
		(char*)info[4].As<Napi::String>().Utf8Value().c_str(),
		info[5].As<Napi::Number>().Int32Value(),
		info[6].As<Napi::Number>().Int32Value(),
		ret,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(ret, 30, env);
	return obj;
}


constexpr std::pair<int, const char*> args41[] = {
	{ 7, "Expecting 7 arguments: tjd_ut, dgeo, datm, dobs, object_name, event_type, hel_flag" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ ARRAY, "Argument 2 should be an array of 3 numbers - geographic coordinates [longitude, latitude, elevation]" },
	{ ARRAY, "Argument 3 should be an array of 4 numbers - atmospheric conditions [pressure, temperature, humidity, meteorological range]" },
	{ ARRAY, "Argument 4 should be an array of 6 numbers - observer description [age, sellen ratio, optical type, optical magnification, optical aperture, optical transmission]" },
	{ STRING, "Argument 5 should be a string - name of fixed star or planet" },
	{ NUMBER, "Argument 6 should be a number - event type" },
	{ NUMBER, "Argument 7 should be a number - calculation flag" }
};

Napi::Value sweph_heliacal_ut(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args41, info)) {
		return env.Null();
	}
	double dgeo [3];
	if(!sweph_double_array_converter(dgeo, 3, info[1])) {
		Napi::TypeError::New(env, args41[2].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double datm [4];
	if(!sweph_double_array_converter(datm, 4, info[2])) {
		Napi::TypeError::New(env, args41[3].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double dobs [6];
	if(!sweph_double_array_converter(dobs, 6, info[3])) {
		Napi::TypeError::New(env, args41[4].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	char serr [AS_MAXCH] = "";
	double ret [50];
	int32 flag = swe_heliacal_ut(
		info[0].As<Napi::Number>().DoubleValue(),
		dgeo,
		datm,
		dobs,
		(char*)info[4].As<Napi::String>().Utf8Value().c_str(),
		info[5].As<Napi::Number>().Int32Value(),
		info[6].As<Napi::Number>().Int32Value(),
		ret,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(ret, 3, env);
	return obj;
}


constexpr std::pair<int, const char*> args42[] = {
	{ 5, "Expecting 5 arguments: ipl, x2cross, jd_et, flag, dir" },
	{ NUMBER, "Argument 1 should be a number - object ID" },
	{ NUMBER, "Argument 2 should be a number - longitude position to search for" },
	{ NUMBER, "Argument 3 should be a number - start time in julian day in ephemeris/terrestrial time" },
	{ NUMBER, "Argument 4 should be a number - calculation flag" },
	{ NUMBER, "Argument 5 should be a number - direction to search, 0 = forwards, -1 = backwards" }
};

Napi::Value sweph_helio_cross(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args42, info)) {
		return env.Null();
	}
	char serr [AS_MAXCH] = "";
	double jd_cross;
	int32 flag = swe_helio_cross(
		info[0].As<Napi::Number>().Int32Value(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().Int32Value(),
		info[3].As<Napi::Number>().Int32Value(),
		info[4].As<Napi::Number>().Int32Value(),
		&jd_cross,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["date"] = jd_cross;
	obj["flag"] = flag;
	obj["error"] = serr;
	return obj;
}


constexpr std::pair<int, const char*> args43[] = {
	{ 5, "Expecting 5 arguments: ipl, x2cross, jd_ut, flag, dir" },
	{ NUMBER, "Argument 1 should be a number - object ID" },
	{ NUMBER, "Argument 2 should be a number - longitude position to search for" },
	{ NUMBER, "Argument 3 should be a number - start time in julian day in universal time" },
	{ NUMBER, "Argument 4 should be a number - calculation flag" },
	{ NUMBER, "Argument 5 should be a number - direction to search, 0 = forwards, -1 = backwards" }
};

Napi::Value sweph_helio_cross_ut(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args43, info)) {
		return env.Null();
	}
	char serr [AS_MAXCH] = "";
	double jd_cross;
	int32 flag = swe_helio_cross_ut(
		info[0].As<Napi::Number>().Int32Value(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().Int32Value(),
		info[3].As<Napi::Number>().Int32Value(),
		info[4].As<Napi::Number>().Int32Value(),
		&jd_cross,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["date"] = jd_cross;
	obj["flag"] = flag;
	obj["error"] = serr;
	return obj;
}


constexpr std::pair<int, const char*> args44[] = {
	{ 1, "Expecting 1 argument: hsys" },
	{ STRING, "Argument 1 should be a string - house system ID" }
};

Napi::Value sweph_house_name(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args44, info)) {
		return env.Null();
	}
	char sys = info[0].As<Napi::String>().Utf8Value()[0];
	const char* name = swe_house_name(int(sys));
	if(name == NULL) {
		Napi::TypeError::New(env, "Invalid house system").ThrowAsJavaScriptException();
		return env.Null();
	}
	return Napi::String::New(env, name);
}


constexpr std::pair<int, const char*> args45[] = {
	{ 5, "Expecting 5 arguments: armc, geolat, eps, hsys, xpin" },
	{ NUMBER, "Argument 1 should be a number - ARMC" },
	{ NUMBER, "Argument 2 should be a number - geographic latitude in degrees" },
	{ NUMBER, "Argument 3 should be a number - obliquity of the ecliptic in degrees" },
	{ STRING, "Argument 4 should be a string - house system ID" },
	{ ARRAY, "Argument 5 should be an array of 2 numbers - ecliptic coordinates of the target [longitude, latitude]" }
};

Napi::Value sweph_house_pos(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args45, info)) {
		return env.Null();
	}
	double planet [2];
	if(!sweph_double_array_converter(planet, 2, info[4])) {
		Napi::TypeError::New(env, args45[5].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	char serr [AS_MAXCH] = "";
	char sys = info[3].As<Napi::String>().Utf8Value()[0];
	double house = swe_house_pos(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().DoubleValue(),
		int(sys),
		planet,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["error"] = serr;
	obj["data"] = house;
	return obj;
}


constexpr std::pair<int, const char*> args46[] = {
	{ 4, "Expecting 4 arguments: tjd_ut, geolat, geolon, hsys" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - geographic latitude in degrees" },
	{ NUMBER, "Argument 3 should be a number - geographic longitude in degrees" },
	{ STRING, "Argument 4 should be a string - house system ID" }
};

Napi::Value sweph_houses(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args46, info)) {
		return env.Null();
	}
	double cusps [37];
	double points [10];
	char sys = info[3].As<Napi::String>().Utf8Value()[0];
	int flag = swe_houses(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().DoubleValue(),
		int(sys),
		cusps,
		points
	);
	int g = sys == 'G' && flag == OK ? 37 : 13;
	Napi::Object data = Napi::Object::New(env);
	data["houses"] = sweph_js_array_converter(&cusps[1], g-1, env);
	data["points"] = sweph_js_array_converter(points, 8, env);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["data"] = data;
	return obj;
}


constexpr std::pair<int, const char*> args47[] = {
	{ 4, "Expecting 4 arguments: armc, geolat, eps, hsys" },
	{ NUMBER, "Argument 1 should be a number - ARMC" },
	{ NUMBER, "Argument 2 should be a number - geographic latitude in degrees" },
	{ NUMBER, "Argument 3 should be a number - obliquity of the ecliptic in degrees" },
	{ STRING, "Argument 4 should be a string - house system ID" }
};

Napi::Value sweph_houses_armc(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args47, info)) {
		return env.Null();
	}
	double cusps [37];
	double points [10];
	if(info[4].IsNumber()) {
		points[9] = info[4].As<Napi::Number>().DoubleValue();
	}
	char sys = info[3].As<Napi::String>().Utf8Value()[0];
	int g = sys == 'G' ? 37 : 13;
	int flag = swe_houses_armc(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().DoubleValue(),
		int(sys),
		cusps,
		points
	);
	Napi::Object data = Napi::Object::New(env);
	data["houses"] = sweph_js_array_converter(&cusps[1], g-1, env);
	data["points"] = sweph_js_array_converter(points, 8, env);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["data"] = data;
	return obj;
}


constexpr std::pair<int, const char*> args48[] = {
	{ 4, "Expecting 4 arguments: armc, geolat, eps, hsys" },
	{ NUMBER, "Argument 1 should be a number - ARMC" },
	{ NUMBER, "Argument 2 should be a number - geographic latitude in degrees" },
	{ NUMBER, "Argument 3 should be a number - obliquity of the ecliptic in degrees" },
	{ STRING, "Argument 4 should be a string - house system ID" }
};

Napi::Value sweph_houses_armc_ex2(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args48, info)) {
		return env.Null();
	}
	double cusps [37];
	double points [10];
	if(info[4].IsNumber()) {
		points[9] = info[4].As<Napi::Number>().DoubleValue();
	}
	double cspeed [37];
	double pspeed [10];
	char serr [AS_MAXCH] = "";
	char sys = info[3].As<Napi::String>().Utf8Value()[0];
	int g = sys == 'G' ? 37 : 13;
	int flag = swe_houses_armc_ex2(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().DoubleValue(),
		int(sys),
		cusps,
		points,
		cspeed,
		pspeed,
		serr
	);
	Napi::Object data = Napi::Object::New(env);
	data["houses"] = sweph_js_array_converter(&cusps[1], g-1, env);
	data["points"] = sweph_js_array_converter(points, 8, env);
	data["housesSpeed"] = sweph_js_array_converter(&cspeed[1], g-1, env);
	data["pointsSpeed"] = sweph_js_array_converter(pspeed, 8, env);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = data;
	return obj;
}


constexpr std::pair<int, const char*> args49[] = {
	{ 5, "Expecting 5 arguments: tjd_ut, iflag, geolat, geolon, hsys" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - calculation flag" },
	{ NUMBER, "Argument 3 should be a number - geographic latitude in degrees" },
	{ NUMBER, "Argument 4 should be a number - geographic longitude in degrees" },
	{ STRING, "Argument 5 should be a string - house system ID" }
};

Napi::Value sweph_houses_ex(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args49, info)) {
		return env.Null();
	}
	double cusps [37];
	double points [10];
	char sys = info[4].As<Napi::String>().Utf8Value()[0];
	int flag = swe_houses_ex(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().DoubleValue(),
		info[3].As<Napi::Number>().DoubleValue(),
		int(sys),
		cusps,
		points
	);
	int g = sys == 'G' && flag == OK ? 37 : 13;
	Napi::Object data = Napi::Object::New(env);
	data["houses"] = sweph_js_array_converter(&cusps[1], g-1, env);
	data["points"] = sweph_js_array_converter(points, 8, env);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["data"] = data;
	return obj;
}


constexpr std::pair<int, const char*> args50[] = {
	{ 5, "Expecting 5 arguments: tjd_ut, iflag, geolat, geolon, hsys" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - calculation flag" },
	{ NUMBER, "Argument 3 should be a number - geographic latitude in degrees" },
	{ NUMBER, "Argument 4 should be a number - geographic longitude in degrees" },
	{ STRING, "Argument 5 should be a string - house system ID" }
};

Napi::Value sweph_houses_ex2(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args50, info)) {
		return env.Null();
	}
	double cusps [37];
	double points [10];
	double cspeed [37];
	double pspeed [10];
	char serr [AS_MAXCH] = "";
	char sys = info[4].As<Napi::String>().Utf8Value()[0];
	int flag = swe_houses_ex2(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().DoubleValue(),
		info[3].As<Napi::Number>().DoubleValue(),
		int(sys),
		cusps,
		points,
		cspeed,
		pspeed,
		serr
	);
	int g = sys == 'G' && flag == OK ? 37 : 13;
	Napi::Object data = Napi::Object::New(env);
	data["houses"] = sweph_js_array_converter(&cusps[1], g-1, env);
	data["points"] = sweph_js_array_converter(points, 8, env);
	data["housesSpeed"] = sweph_js_array_converter(&cspeed[1], g-1, env);
	data["pointsSpeed"] = sweph_js_array_converter(pspeed, 8, env);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = data;
	return obj;
}


constexpr std::pair<int, const char*> args51[] = {
	{ 2, "Expecting 2 arguments: tjd_et, gregflag" },
	{ NUMBER, "Argument 1 should be a number - julian day in ephemeris/terrestrial time" },
	{ NUMBER, "Argument 2 should be a number - calendar system, 1 for SE_GREG_CAL, 0 for SE_JUL_CAL" }
};

Napi::Value sweph_jdet_to_utc(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args51, info)) {
		return env.Null();
	}
	int year;
	int month;
	int day;
	int hour;
	int minute;
	double second;
	swe_jdet_to_utc(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		&year,
		&month,
		&day,
		&hour,
		&minute,
		&second
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["year"] = year;
	obj["month"] = month;
	obj["day"] = day;
	obj["hour"] = hour;
	obj["minute"] = minute;
	obj["second"] = second;
	return obj;
}


constexpr std::pair<int, const char*> args52[] = {
	{ 2, "Expecting 2 arguments: tjd_ut, gregflag" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - calendar system, 1 for SE_GREG_CAL, 0 for SE_JUL_CAL" }
};

Napi::Value sweph_jdut1_to_utc(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args52, info)) {
		return env.Null();
	}
	int year;
	int month;
	int day;
	int hour;
	int minute;
	double second;
	swe_jdut1_to_utc(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		&year,
		&month,
		&day,
		&hour,
		&minute,
		&second
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["year"] = year;
	obj["month"] = month;
	obj["day"] = day;
	obj["hour"] = hour;
	obj["minute"] = minute;
	obj["second"] = second;
	return obj;
}


constexpr std::pair<int, const char*> args53[] = {
	{ 5, "Expecting 5 arguments: year, month, day, hour, gregflag" },
	{ NUMBER, "Argument 1 should be a number - full year" },
	{ NUMBER, "Argument 2 should be a number - month 1-12" },
	{ NUMBER, "Argument 3 should be a number - day 1-31" },
	{ NUMBER, "Argument 4 should be a number - decimal hour 0-23.999" },
	{ NUMBER, "Argument 5 should be a number - calendar system, 1 for SE_GREG_CAL, 0 for SE_JUL_CAL" }
};

Napi::Value sweph_julday(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args53, info)) {
		return env.Null();
	}
	double time = swe_julday(
		info[0].As<Napi::Number>().Int32Value(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		info[3].As<Napi::Number>().DoubleValue(),
		info[4].As<Napi::Number>().Int32Value()
	);
	return Napi::Number::New(env, time);
}


constexpr std::pair<int, const char*> args54[] = {
	{ 2, "Expecting 2 arguments: tjd_lat, geolon" },
	{ NUMBER, "Argument 1 should be a number - julian day in local apparent time" },
	{ NUMBER, "Argument 2 should be a number - geographic longitude" }
};

Napi::Value sweph_lat_to_lmt(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args54, info)) {
		return env.Null();
	}
	double conv;
	char serr [AS_MAXCH] = "";
	int32 flag = swe_lat_to_lmt(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		&conv,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = conv;
	return obj;
}


constexpr std::pair<int, const char*> args55[] = {
	{ 2, "Expecting 2 arguments: tjd_lmt, geolon" },
	{ NUMBER, "Argument 1 should be a number - julian day in local mean time" },
	{ NUMBER, "Argument 2 should be a number - geographic longitude" }
};

Napi::Value sweph_lmt_to_lat(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args55, info)) {
		return env.Null();
	}
	double conv;
	char serr [AS_MAXCH] = "";
	int32 flag = swe_lmt_to_lat(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		&conv,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = conv;
	return obj;
}


constexpr std::pair<int, const char*> args56[] = {
	{ 3, "Expecting 3 arguments: tjd_ut, ifl, geopos" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - ephemeris flag" },
	{ ARRAY, "Argument 3 should be an array of 3 numbers - geographic coordinates [longitude, latitude, elevation]" }
};

Napi::Value sweph_lun_eclipse_how(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args56, info)) {
		return env.Null();
	}
	double geopos [3];
	if(!sweph_double_array_converter(geopos, 3, info[2])) {
		Napi::TypeError::New(env, args56[3].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double attr [20];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_lun_eclipse_how(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		geopos,
		attr,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(attr, 11, env);
	return obj;
}


constexpr std::pair<int, const char*> args57[] = {
	{ 4, "Expecting 4 arguments: tjd_start, ifl, ifltype, backward" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - ephemeris flag" },
	{ NUMBER, "Argument 3 should be a number - eclipse type" },
	{ TRUEFALSE, "Argument 4 should be a boolean - backwards search" }
};

Napi::Value sweph_lun_eclipse_when(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args57, info)) {
		return env.Null();
	}
	double ret [10];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_lun_eclipse_when(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		ret,
		info[3].As<Napi::Boolean>(),
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(ret, 8, env);
	return obj;
}


constexpr std::pair<int, const char*> args58[] = {
	{ 4, "Expecting 4 arguments: tjd_start, ifl, geopos, backward" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - ephemeris flag" },
	{ ARRAY, "Argument 3 should be an array of 3 numbers - geographic coordinates [longitude, latitude, elevation]" },
	{ TRUEFALSE, "Argument 4 should be a boolean - backwards search" }
};

Napi::Value sweph_lun_eclipse_when_loc(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args58, info)) {
		return env.Null();
	}
	double geopos [3];
	if(!sweph_double_array_converter(geopos, 3, info[2])) {
		Napi::TypeError::New(env, args58[3].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double ret [10];
	double attr [20];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_lun_eclipse_when_loc(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		geopos,
		ret,
		attr,
		info[3].As<Napi::Boolean>(),
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(ret, 10, env);
	obj["attributes"] = sweph_js_array_converter(attr, 11, env);
	return obj;
}


constexpr std::pair<int, const char*> args59[] = {
	{ 6, "Expecting 6 arguments: tjd_start, ipl, starname, ifl, ifltype, backward" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ STRINGNULL, "Argument 3 should be a string or NULL - target star name" },
	{ NUMBER, "Argument 4 should be a number - ephemeris flag" },
	{ NUMBER, "Argument 5 should be a number - eclipse type" },
	{ TRUEFALSE, "Argument 6 should be a boolean - backwards search" }
};

Napi::Value sweph_lun_occult_when_glob(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args59, info)) {
		return env.Null();
	}
	double ret [10];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_lun_occult_when_glob(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].IsString() ? (char*)info[2].As<Napi::String>().Utf8Value().c_str() : NULL,
		info[3].As<Napi::Number>().Int32Value(),
		info[4].As<Napi::Number>().Int32Value(),
		ret,
		info[5].As<Napi::Boolean>(),
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(ret, 10, env);
	return obj;
}


constexpr std::pair<int, const char*> args60[] = {
	{ 6, "Expecting 6 arguments: tjd_start, ipl, starname, ifl, geopos, backward" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ STRINGNULL, "Argument 3 should be a string or NULL - target star name" },
	{ NUMBER, "Argument 4 should be a number - ephemeris flag" },
	{ ARRAY, "Argument 5 should be an array of 3 numbers - geographic coordinates [longitude, latitude, elevation]" },
	{ TRUEFALSE, "Argument 6 should be a boolean - backwards search" }
};

Napi::Value sweph_lun_occult_when_loc(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args60, info)) {
		return env.Null();
	}
	double geopos [3];
	if(!sweph_double_array_converter(geopos, 3, info[0])) {
		Napi::TypeError::New(env, args60[1].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double ret [10];
	double attr [20];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_lun_occult_when_loc(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].IsString() ? (char*)info[2].As<Napi::String>().Utf8Value().c_str() : NULL,
		info[3].As<Napi::Number>().Int32Value(),
		geopos,
		ret,
		attr,
		info[5].As<Napi::Boolean>(),
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(ret, 7, env);
	obj["attributes"] = sweph_js_array_converter(attr, 8, env);
	return obj;
}


constexpr std::pair<int, const char*> args61[] = {
	{ 4, "Expecting 4 arguments: tjd_ut, ipl, starname, ifl" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ STRINGNULL, "Argument 3 should be a string or NULL - target star name" },
	{ NUMBER, "Argument 4 should be a number - ephemeris flag" }
};

Napi::Value sweph_lun_occult_where(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args61, info)) {
		return env.Null();
	}
	double geopos [10];
	double attr [20];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_lun_occult_where(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].IsString() ? (char*)info[2].As<Napi::String>().Utf8Value().c_str() : NULL,
		info[3].As<Napi::Number>().Int32Value(),
		geopos,
		attr,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(geopos, 10, env);
	obj["attributes"] = sweph_js_array_converter(attr, 8, env);
	return obj;
}


constexpr std::pair<int, const char*> args62[] = {
	{ 3, "Expecting 3 arguments: x2cross, jd_et, flag" },
	{ NUMBER, "Argument 1 should be a number - longitude position to search for" },
	{ NUMBER, "Argument 2 should be a number - start time in julian day in ephemeris/terrestrial time" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_mooncross(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args62, info)) {
		return env.Null();
	}
	char serr [AS_MAXCH] = "";
	double jd_et = swe_mooncross(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().Int32Value(),
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["date"] = jd_et;
	obj["error"] = serr;
	return obj;
}


constexpr std::pair<int, const char*> args63[] = {
	{ 2, "Expecting 2 arguments: jd_et, flag" },
	{ NUMBER, "Argument 1 should be a number - start time in julian day in ephemeris/terrestrial time" },
	{ NUMBER, "Argument 2 should be a number - calculation flag" }
};

Napi::Value sweph_mooncross_node(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args63, info)) {
		return env.Null();
	}
	char serr [AS_MAXCH] = "";
	double xlon;
	double xlat;
	double jd_et = swe_mooncross_node(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		&xlon,
		&xlat,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["date"] = jd_et;
	obj["error"] = serr;
	obj["longitude"] = xlon;
	obj["latitude"] = xlat;
	return obj;
}


constexpr std::pair<int, const char*> args64[] = {
	{ 2, "Expecting 2 arguments: jd_ut, flag" },
	{ NUMBER, "Argument 1 should be a number - start time in julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - calculation flag" }
};

Napi::Value sweph_mooncross_node_ut(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args64, info)) {
		return env.Null();
	}
	char serr [AS_MAXCH] = "";
	double xlon;
	double xlat;
	double jd_ut = swe_mooncross_node_ut(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		&xlon,
		&xlat,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["date"] = jd_ut;
	obj["error"] = serr;
	obj["longitude"] = xlon;
	obj["latitude"] = xlat;
	return obj;
}


constexpr std::pair<int, const char*> args65[] = {
	{ 3, "Expecting 3 arguments: x2cross, jd_ut, flag" },
	{ NUMBER, "Argument 1 should be a number - longitude position to search for" },
	{ NUMBER, "Argument 2 should be a number - start time in julian days in universal time" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_mooncross_ut(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args65, info)) {
		return env.Null();
	}
	char serr [AS_MAXCH] = "";
	double jd_ut = swe_mooncross_ut(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().Int32Value(),
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["date"] = jd_ut;
	obj["error"] = serr;
	return obj;
}


constexpr std::pair<int, const char*> args66[] = {
	{ 4, "Expecting 4 arguments: tjd_et, ipl, iflag, method" },
	{ NUMBER, "Argument 1 should be a number - julian day in ephemeris/terrestrial time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" },
	{ NUMBER, "Argument 4 should be a number - calculation method" }
};

Napi::Value sweph_nod_aps(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args66, info)) {
		return env.Null();
	}
	double asc [6];
	double dsc [6];
	double per [6];
	double aph [6];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_nod_aps(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		info[3].As<Napi::Number>().Int32Value(),
		asc,
		dsc,
		per,
		aph,
		serr
	);
	Napi::Object data = Napi::Object::New(env);
	data["ascending"] = sweph_js_array_converter(asc, 6, env);
	data["descending"] = sweph_js_array_converter(dsc, 6, env);
	data["perihelion"] = sweph_js_array_converter(per, 6, env);
	data["aphelion"] = sweph_js_array_converter(aph, 6, env);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = data;
	return obj;
}


constexpr std::pair<int, const char*> args67[] = {
	{ 4, "Expecting 4 arguments: tjd_ut, ipl, iflag, method" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" },
	{ NUMBER, "Argument 4 should be a number - calculation method" }
};

Napi::Value sweph_nod_aps_ut(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args67, info)) {
		return env.Null();
	}
	double asc [6];
	double dsc [6];
	double per [6];
	double aph [6];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_nod_aps_ut(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		info[3].As<Napi::Number>().Int32Value(),
		asc,
		dsc,
		per,
		aph,
		serr
	);
	Napi::Object data = Napi::Object::New(env);
	data["ascending"] = sweph_js_array_converter(asc, 6, env);
	data["descending"] = sweph_js_array_converter(dsc, 6, env);
	data["perihelion"] = sweph_js_array_converter(per, 6, env);
	data["aphelion"] = sweph_js_array_converter(aph, 6, env);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = data;
	return obj;
}


constexpr std::pair<int, const char*> args68[] = {
	{ 3, "Expecting 3 arguments: tjd_et, ipl, iflag" },
	{ NUMBER, "Argument 1 should be a number - julian day in ephemeris/terrestrial time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_orbit_max_min_true_distance(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args68, info)) {
		return env.Null();
	}
	double dmax;
	double dmin;
	double dtrue;
	char serr [AS_MAXCH] = "";
	int32 flag = swe_orbit_max_min_true_distance(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		&dmax,
		&dmin,
		&dtrue,
		serr
	);
	Napi::Object data = Napi::Object::New(env);
	data["max"] = dmax;
	data["min"] = dmin;
	data["true"] = dtrue;
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = data;
	return obj;
}


constexpr std::pair<int, const char*> args69[] = {
	{ 3, "Expecting 3 arguments: tjd_et, ipl, iflag" },
	{ NUMBER, "Argument 1 should be a number - julian day in ephemeris/terrestrial time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_pheno(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args69, info)) {
		return env.Null();
	}
	double attr [20];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_pheno(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		attr,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(attr, 5, env);
	return obj;
}


constexpr std::pair<int, const char*> args70[] = {
	{ 3, "Expecting 3 arguments: tjd_ut, ipl, iflag" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_pheno_ut(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args70, info)) {
		return env.Null();
	}
	double attr [20];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_pheno_ut(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		attr,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(attr, 5, env);
	return obj;
}


constexpr std::pair<int, const char*> args71[] = {
	{ 1, "Expecting 1 arguments: drad" },
	{ NUMBER, "Argument 1 should be a number - degrees in radians" }
};

Napi::Value sweph_radnorm(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args71, info)) {
		return env.Null();
	}
	double rad = swe_radnorm(info[0].As<Napi::Number>().DoubleValue());
	return Napi::Number::New(env, rad);
}


constexpr std::pair<int, const char*> args72[] = {
	{ 4, "Expecting 4 arguments: inalt, atpress, attemp, calc_flag" },
	{ NUMBER, "Argument 1 should be a number - altitude above horizon in degrees" },
	{ NUMBER, "Argument 2 should be a number - atmospheric pressure in mbar/hpa" },
	{ NUMBER, "Argument 3 should be a number - atmospheric temperature in celsius" },
	{ NUMBER, "Argument 4 should be a number - calculation flag" }
};

Napi::Value sweph_refrac(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args72, info)) {
		return env.Null();
	}
	double out = swe_refrac(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().DoubleValue(),
		info[3].As<Napi::Number>().Int32Value()
	);
	return Napi::Number::New(env, out);
}


constexpr std::pair<int, const char*> args73[] = {
	{ 6, "Expecting 6 arguments: inalt, geoalt, atpress, attemp, lapse_rate, calc_flag" },
	{ NUMBER, "Argument 1 should be a number - altitude above horizon in degrees" },
	{ NUMBER, "Argument 2 should be a number - altitude of observer in meters" },
	{ NUMBER, "Argument 3 should be a number - atmospheric pressure in mbar/hpa" },
	{ NUMBER, "Argument 4 should be a number - atmospheric temperature in celsius" },
	{ NUMBER, "Argument 5 should be a number - lapse rate (attemp/geoalt) = [K/m]" },
	{ NUMBER, "Argument 6 should be a number - calculation flag" }
};

Napi::Value sweph_refrac_extended(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args73, info)) {
		return env.Null();
	}
	double ret [20];
	double out = swe_refrac_extended(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().DoubleValue(),
		info[3].As<Napi::Number>().DoubleValue(),
		info[4].As<Napi::Number>().DoubleValue(),
		info[5].As<Napi::Number>().Int32Value(),
		ret
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["data"] = out;
	obj["extended"] = sweph_js_array_converter(ret, 4, env);
	return obj;
}



constexpr std::pair<int, const char*> args74[] = {
	{ 2, "Expecting 2 arguments: tjd, gregflag" },
	{ NUMBER, "Argument 1 should be a number - julian day number" },
	{ NUMBER, "Argument 2 should be a number - calendar system, 1 for SE_GREG_CAL, 0 for SE_JUL_CAL" }
};

Napi::Value sweph_revjul(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args74, info)) {
		return env.Null();
	}
	int year;
	int month;
	int day;
	double time;
	swe_revjul(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		&year,
		&month,
		&day,
		&time
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["year"] = year;
	obj["month"] = month;
	obj["day"] = day;
	obj["hour"] = time;
	return obj;
}


constexpr std::pair<int, const char*> args75[] = {
	{ 8, "Expecting 8 arguments: tjd_ut, ipl, starname, epheflag, rsmi, geopos, atpress, attemp" },
	{ NUMBER, "Argument 1 should be a number - julian day number" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ STRINGNULL, "Argument 3 should be a string or NULL - target star name" },
	{ NUMBER, "Argument 4 should be a number - calculation flag" },
	{ NUMBER, "Argument 5 should be a number - transit type" },
	{ ARRAY, "Argument 6 should be an array - geographic coordinates [longitude, latitude, elevation]" },
	{ NUMBER, "Argument 7 should be a number - atmospheric pressure in mbar/hpa" },
	{ NUMBER, "Argument 8 should be a number - atmospheric temperature in celsius" }
};

Napi::Value sweph_rise_trans(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args75, info)) {
		return env.Null();
	}
	double geopos [3];
	if(!sweph_double_array_converter(geopos, 3, info[5])) {
		Napi::TypeError::New(env, args75[6].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double ret;
	char serr [AS_MAXCH] = "";
	int32 flag = swe_rise_trans(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].IsString() ? (char*)info[2].As<Napi::String>().Utf8Value().c_str() : NULL,
		info[3].As<Napi::Number>().Int32Value(),
		info[4].As<Napi::Number>().Int32Value(),
		geopos,
		info[6].As<Napi::Number>().DoubleValue(),
		info[7].As<Napi::Number>().DoubleValue(),
		&ret,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = ret;
	return obj;
}


constexpr std::pair<int, const char*> args76[] = {
	{ 9, "Expecting 9 arguments: tjd_ut, ipl, starname, epheflag, rsmi, geopos, atpress, attemp, horhgt" },
	{ NUMBER, "Argument 1 should be a number - julian day number" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ STRINGNULL, "Argument 3 should be a string or NULL - target star name" },
	{ NUMBER, "Argument 4 should be a number - calculation flag" },
	{ NUMBER, "Argument 5 should be a number - transit type" },
	{ ARRAY, "Argument 6 should be an array - geographic coordinates [longitude, latitude, elevation]" },
	{ NUMBER, "Argument 7 should be a number - atmospheric pressure in mbar/hpa" },
	{ NUMBER, "Argument 8 should be a number - atmospheric temperature in celsius" },
	{ NUMBER, "Argument 9 should be a number - height of the local horizon in degrees" }
};

Napi::Value sweph_rise_trans_true_hor(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args76, info)) {
		return env.Null();
	}
	double geopos [3];
	if(!sweph_double_array_converter(geopos, 3, info[5])) {
		Napi::TypeError::New(env, args76[6].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double ret;
	char serr [AS_MAXCH] = "";
	int32 flag = swe_rise_trans_true_hor(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].IsString() ? (char*)info[2].As<Napi::String>().Utf8Value().c_str() : NULL,
		info[3].As<Napi::Number>().Int32Value(),
		info[4].As<Napi::Number>().Int32Value(),
		geopos,
		info[6].As<Napi::Number>().DoubleValue(),
		info[7].As<Napi::Number>().DoubleValue(),
		info[8].As<Napi::Number>().DoubleValue(),
		&ret,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = ret;
	return obj;
}


constexpr std::pair<int, const char*> args77[] = {
	{ 1, "Expecting 1 arguments: t_acc" },
	{ NUMBER, "Argument 1 should be a number - delta T value" }
};

void sweph_set_delta_t_userdef(const Napi::CallbackInfo& info) {
	if(!sweph_type_check(args77, info)) {
		return;
	}
	swe_set_delta_t_userdef(info[0].As<Napi::Number>().DoubleValue());
	return;
}


constexpr std::pair<int, const char*> args78[] = {
	{ 1, "Expecting 1 arguments: path" },
	{ STRINGNULL, "Argument 1 should be a string or NULL - path to ephemeris files" }
};

void sweph_set_ephe_path(const Napi::CallbackInfo& info) {
	if(!sweph_type_check(args78, info)) {
		return;
	}
	swe_set_ephe_path(info[0].IsString() ? info[0].As<Napi::String>().Utf8Value().c_str() : NULL);
	return;
}


constexpr std::pair<int, const char*> args79[] = {
	{ 1, "Expecting 1 arguments: fname" },
	{ STRING, "Argument 1 should be a string - JPL file name" }
};

void sweph_set_jpl_file(const Napi::CallbackInfo& info) {
	if(!sweph_type_check(args79, info)) {
		return;
	}
	swe_set_jpl_file(info[0].As<Napi::String>().Utf8Value().c_str());
	return;
}


constexpr std::pair<int, const char*> args80[] = {
	{ 3, "Expecting 3 arguments: sid_mode, t0, ayan_t0" },
	{ NUMBER, "Argument 1 should be a number - ayanamsa ID" },
	{ NUMBER, "Argument 2 should be a number - reference date in julian days universal time" },
	{ NUMBER, "Argument 3 should be a number - initial value in degrees" }
};

void sweph_set_sid_mode(const Napi::CallbackInfo& info) {
	if(!sweph_type_check(args80, info)) {
		return;
	}
	swe_set_sid_mode(
		info[0].As<Napi::Number>().Int32Value(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().DoubleValue()
	);
	return;
}


constexpr std::pair<int, const char*> args81[] = {
	{ 1, "Expecting 1 arguments: t_acc" },
	{ NUMBER, "Argument 1 should be a number - tidal acceleration value" }
};

void sweph_set_tid_acc(const Napi::CallbackInfo& info) {
	if(!sweph_type_check(args81, info)) {
		return;
	}
	swe_set_tid_acc(info[0].As<Napi::Number>().DoubleValue());
	return;
}


constexpr std::pair<int, const char*> args82[] = {
	{ 3, "Expecting 3 arguments: geolon, geolat, elevation" },
	{ NUMBER, "Argument 1 should be a number - geographical longitude" },
	{ NUMBER, "Argument 2 should be a number - geographical latitude" },
	{ NUMBER, "Argument 3 should be a number - elevation" }
};

void sweph_set_topo(const Napi::CallbackInfo& info) {
	if(!sweph_type_check(args82, info)) {
		return;
	}
	swe_set_topo(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().DoubleValue()
	);
	return;
}


constexpr std::pair<int, const char*> args83[] = {
	{ 1, "Expecting 1 arguments: tjd_ut" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" }
};

Napi::Value sweph_sidtime(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args83, info)) {
		return env.Null();
	}
	double val = swe_sidtime(info[0].As<Napi::Number>().DoubleValue());
	return Napi::Number::New(env, val);
}


constexpr std::pair<int, const char*> args84[] = {
	{ 3, "Expecting 3 arguments: tjd_ut, eps, nut" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - obliquity of the ecliptic" },
	{ NUMBER, "Argument 3 should be a number - nutation" }
};

Napi::Value sweph_sidtime0(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args84, info)) {
		return env.Null();
	}
	double time = swe_sidtime0(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().DoubleValue()
	);
	return Napi::Number::New(env, time);
}


constexpr std::pair<int, const char*> args85[] = {
	{ 3, "Expecting 3 arguments: tjd_ut, ifl, geopos" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ ARRAY, "Argument 3 should be an array of 3 numbers - geographic coordinates [longitude, latitude, elevation]" }
};

Napi::Value sweph_sol_eclipse_how(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args85, info)) {
		return env.Null();
	}
	double geopos [3];
	if(!sweph_double_array_converter(geopos, 3, info[2])) {
		Napi::TypeError::New(env, args85[3].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double attr [20];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_sol_eclipse_how(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		geopos,
		attr,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(attr, 11, env);
	return obj;
}


constexpr std::pair<int, const char*> args86[] = {
	{ 4, "Expecting 4 arguments: tjd_start, ifl, ifltype, backward" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ NUMBER, "Argument 3 should be a number - eclipse type" },
	{ TRUEFALSE, "Argument 4 should be a boolean - backwards search" }
};

Napi::Value sweph_sol_eclipse_when_glob(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args86, info)) {
		return env.Null();
	}
	double ret [10];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_sol_eclipse_when_glob(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		ret,
		info[3].As<Napi::Boolean>(),
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(ret, 10, env);
	return obj;
}


constexpr std::pair<int, const char*> args87[] = {
	{ 4, "Expecting 4 arguments: tjd_start, ifl, geopos, backward" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" },
	{ ARRAY, "Argument 3 should be an array of 3 numbers - geographic coordinates [longitude, latitude, elevation]" },
	{ TRUEFALSE, "Argument 4 should be a boolean - backwards search" }
};

Napi::Value sweph_sol_eclipse_when_loc(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args87, info)) {
		return env.Null();
	}
	double geopos [3];
	if(!sweph_double_array_converter(geopos, 3, info[2])) {
		Napi::TypeError::New(env, args87[3].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double ret [10];
	double attr [20];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_sol_eclipse_when_loc(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		geopos,
		ret,
		attr,
		info[3].As<Napi::Boolean>(),
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(ret, 7, env);
	obj["attributes"] = sweph_js_array_converter(attr, 11, env);
	return obj;
}


constexpr std::pair<int, const char*> args88[] = {
	{ 2, "Expecting 2 arguments: tjd_ut, ifl" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" },
	{ NUMBER, "Argument 2 should be a number - target object ID" }
};

Napi::Value sweph_sol_eclipse_where(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args88, info)) {
		return env.Null();
	}
	double geopos [10];
	double attr [20];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_sol_eclipse_where(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		geopos,
		attr,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(geopos, 10, env);
	obj["attributes"] = sweph_js_array_converter(attr, 11, env);
	return obj;
}


constexpr std::pair<int, const char*> args89[] = {
	{ 3, "Expecting 3 arguments: x2cross, jd_et, flag" },
	{ NUMBER, "Argument 1 should be a number - longitude position to search for" },
	{ NUMBER, "Argument 2 should be a number - start time in julian day in ephemeris/terrestrial time" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_solcross(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args89, info)) {
		return env.Null();
	}
	char serr [AS_MAXCH] = "";
	double jd_et = swe_solcross(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().Int32Value(),
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["date"] = jd_et;
	obj["error"] = serr;
	return obj;
}


constexpr std::pair<int, const char*> args90[] = {
	{ 3, "Expecting 3 arguments: x2cross, jd_ut, flag" },
	{ NUMBER, "Argument 1 should be a number - longitude position to search for" },
	{ NUMBER, "Argument 2 should be a number - start time in julian day in universal time" },
	{ NUMBER, "Argument 3 should be a number - calculation flag" }
};

Napi::Value sweph_solcross_ut(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args90, info)) {
		return env.Null();
	}
	char serr [AS_MAXCH] = "";
	double jd_ut = swe_solcross_ut(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().DoubleValue(),
		info[2].As<Napi::Number>().Int32Value(),
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["date"] = jd_ut;
	obj["error"] = serr;
	return obj;
}


constexpr std::pair<int, const char*> args91[] = {
	{ 2, "Expecting 2 arguments: ddeg, roundflag" },
	{ NUMBER, "Argument 1 should be a number - decimal degrees" },
	{ NUMBER, "Argument 2 should be a number - rounding flag" }
};

Napi::Value sweph_split_deg(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args91, info)) {
		return env.Null();
	}
	int deg;
	int min;
	int sec;
	double fraction;
	int sign;
	swe_split_deg(
		info[0].As<Napi::Number>().DoubleValue(),
		info[1].As<Napi::Number>().Int32Value(),
		&deg,
		&min,
		&sec,
		&fraction,
		&sign
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["degree"] = deg;
	obj["minute"] = min;
	obj["second"] = sec;
	obj["fraction"] = fraction;
	obj["sign"] = sign;
	return obj;
}


constexpr std::pair<int, const char*> args92[] = {
	{ 1, "Expecting 1 arguments: tjd_ut" },
	{ NUMBER, "Argument 1 should be a number - julian day in universal time" }
};

Napi::Value sweph_time_equ(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args92, info)) {
		return env.Null();
	}
	double e;
	char serr [AS_MAXCH] = "";
	int32 flag = swe_time_equ(
		info[0].As<Napi::Number>().DoubleValue(),
		&e,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = e;
	return obj;
}


constexpr std::pair<int, const char*> args93[] = {
	{ 7, "Expecting 7 arguments: iyear, imonth, iday, ihour, imin, dsec, d_timezone" },
	{ NUMBER, "Argument 1 should be a number - full year" },
	{ NUMBER, "Argument 2 should be a number - month 1-12" },
	{ NUMBER, "Argument 3 should be a number - day 1-31" },
	{ NUMBER, "Argument 4 should be a number - hour 0-23" },
	{ NUMBER, "Argument 5 should be a number - minutes 0-59" },
	{ NUMBER, "Argument 6 should be a number - seconds 0-59.999" },
	{ NUMBER, "Argument 7 should be a number - timezone offset" }
};

Napi::Value sweph_utc_time_zone(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args93, info)) {
		return env.Null();
	}
	int year;
	int month;
	int day;
	int hour;
	int minute;
	double seconds;
	swe_utc_time_zone(
		info[0].As<Napi::Number>().Int32Value(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		info[3].As<Napi::Number>().Int32Value(),
		info[4].As<Napi::Number>().Int32Value(),
		info[5].As<Napi::Number>().DoubleValue(),
		info[6].As<Napi::Number>().DoubleValue(),
		&year,
		&month,
		&day,
		&hour,
		&minute,
		&seconds
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["year"] = year;
	obj["month"] = month;
	obj["day"] = day;
	obj["hour"] = hour;
	obj["minute"] = minute;
	obj["second"] = seconds;
	return obj;
}


constexpr std::pair<int, const char*> args94[] = {
	{ 7, "Expecting 7 arguments: iyear, imonth, iday, ihour, imin, dsec, gregflag" },
	{ NUMBER, "Argument 1 should be a number - full year" },
	{ NUMBER, "Argument 2 should be a number - month 1-12" },
	{ NUMBER, "Argument 3 should be a number - day 1-31" },
	{ NUMBER, "Argument 4 should be a number - hour 0-23" },
	{ NUMBER, "Argument 5 should be a number - minutes 0-59" },
	{ NUMBER, "Argument 6 should be a number - seconds 0-59.999" },
	{ NUMBER, "Argument 7 should be a number - calendar system, 1 for SE_GREG_CAL, 0 for SE_JUL_CAL" }
};

Napi::Value sweph_utc_to_jd(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args94, info)) {
		return env.Null();
	}
	double ret [2];
	char serr [AS_MAXCH] = "";
	int32 flag = swe_utc_to_jd(
		info[0].As<Napi::Number>().Int32Value(),
		info[1].As<Napi::Number>().Int32Value(),
		info[2].As<Napi::Number>().Int32Value(),
		info[3].As<Napi::Number>().Int32Value(),
		info[4].As<Napi::Number>().Int32Value(),
		info[5].As<Napi::Number>().DoubleValue(),
		info[6].As<Napi::Number>().Int32Value(),
		ret,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(ret, 2, env);
	return obj;
}


Napi::String sweph_version(const Napi::CallbackInfo& info) {
    Napi::Env env = info.Env();
    char version [AS_MAXCH];
    swe_version(version);
    return Napi::String::New(env, version);
}


constexpr std::pair<int, const char*> args96[] = {
	{ 6, "Expecting 6 arguments: tjd_ut, dgeo, datm, dobs, objectname, helflag" },
	{ NUMBER, "Argument 1 should be a number - full year" },
	{ ARRAY, "Argument 2 should be an array of 3 numbers - geographic coordinates [longitude, latitude, elevation]" },
	{ ARRAY, "Argument 3 should be an array of 4 numbers - atmospheric conditions [pressure, temperature, humidity, meteorological range]" },
	{ ARRAY, "Argument 4 should be an array of 6 numbers - observer description [age, sellen ratio, optical type, optical magnification, optical aperture, optical transmission]" },
	{ STRING, "Argument 5 should be a string - object name" },
	{ NUMBER, "Argument 6 should be a number - calculation flag" }
};

Napi::Value sweph_vis_limit_mag(const Napi::CallbackInfo& info) {
	Napi::Env env = info.Env();
	if(!sweph_type_check(args96, info)) {
		return env.Null();
	}
	double dgeo [3];
	if(!sweph_double_array_converter(dgeo, 3, info[1])) {
		Napi::TypeError::New(env, args96[2].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double datm [4];
	if(!sweph_double_array_converter(datm, 4, info[2])) {
		Napi::TypeError::New(env, args96[3].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	double dobs [6];
	if(!sweph_double_array_converter(dobs, 6, info[3])) {
		Napi::TypeError::New(env, args96[4].second).ThrowAsJavaScriptException();
		return env.Null();
	}
	char serr [AS_MAXCH] = "";
	double ret [8];
	int32 flag = swe_vis_limit_mag(
		info[0].As<Napi::Number>().DoubleValue(),
		dgeo,
		datm,
		dobs,
		(char*)info[4].As<Napi::String>().Utf8Value().c_str(),
		info[5].As<Napi::Number>().Int32Value(),
		ret,
		serr
	);
	Napi::Object obj = Napi::Object::New(env);
	obj["flag"] = flag;
	obj["error"] = serr;
	obj["data"] = sweph_js_array_converter(ret, 8, env);
	return obj;
}
